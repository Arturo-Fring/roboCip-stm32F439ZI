// encoder.h
//
// Интерфейс модуля энкодеров.
// Два одноканальных энкодера (левый и правый) подключены к:
//   Левый  -> PA5 → EXTI5
//   Правый -> PA6 → EXTI6
//
// Используется прерывание EXTI на обоих фронтах,
// а тик детектируется по переходу HIGH → LOW.
//
// Модуль предоставляет:
//   - инициализацию GPIO + EXTI
//   - подсчёт относительных и абсолютных тиков
//   - перевод тиков в мм/м

#ifndef ENCODER_H
#define ENCODER_H

#include "stm32f4xx.h"

/* --------------------------------------------------------------------------
 * Конфигурация пинов энкодеров
 * -------------------------------------------------------------------------- */

// Левый энкодер: PA5 → EXTI5
#define ENC_L_GPIO GPIOA
#define ENC_L_GPIO_CLK RCC_AHB1ENR_GPIOAEN
#define ENC_L_PIN 5
#define ENC_L_EXTI_LINE 5

// Правый энкодер: PA6 → EXTI6
#define ENC_R_GPIO GPIOA
#define ENC_R_GPIO_CLK RCC_AHB1ENR_GPIOAEN
#define ENC_R_PIN 6
#define ENC_R_EXTI_LINE 6

// Линии 5..9 используют один общий обработчик
#define ENC_IRQN EXTI9_5_IRQn

/* --------------------------------------------------------------------------
 * Параметры энкодера и колеса
 * -------------------------------------------------------------------------- */

// Количество импульсов на оборот
#define ENC_PULSES_PER_REV 40U // Укажи точное значение под твой энкодер

// Диаметр и окружность колеса
#define WHEEL_DIAMETER_MM 65.0f
#define WHEEL_CIRCUMFERENCE_MM (3.1415926f * WHEEL_DIAMETER_MM)

// Калибровочный коэффициент 0.95 — поправка реальной механики
#define ENC_MM_PER_TICK (WHEEL_CIRCUMFERENCE_MM / ENC_PULSES_PER_REV) * 0.95f
#define ENC_M_PER_TICK (ENC_MM_PER_TICK / 1000.0f)

// Минимальный интервал между тиками (мс) — защита от дребезга
#define ENC_MIN_TICK_INTERVAL_MS 2U

#ifdef __cplusplus
extern "C"
{
#endif

    /* Инициализация модуля энкодеров */
    void Encoder_Init(void);

    /* Получить тики за интервал dt (и обнулить) */
    void Encoder_GetAndResetTicks(uint32_t *leftTicks, uint32_t *rightTicks);

    /* Суммарные тики с момента включения */
    uint32_t Encoder_GetTotalLeft(void);
    uint32_t Encoder_GetTotalRight(void);

    /* Конвертация тиков */
    float Encoder_TicksToMM(uint32_t ticks);
    float Encoder_TicksToMeters(uint32_t ticks);

#ifdef __cplusplus
}
#endif

#endif /* ENCODER_H */

/******************************************************************************
 *                        КАК РАБОТАЮТ ЭНКОДЕРЫ И СЧЁТЧИКИ
 *
 * 1) Общая идея
 *    У нас есть два одноканальных энкодера (левый и правый), подключённых
 *    к пинам PA5 и PA6. Каждый раз, когда энкодер выдаёт импульс,
 *    на соответствующей линии происходит "фронт" (переход сигнала).
 *
 *    Чтобы не опрашивать пины вручную, используется аппаратный механизм EXTI:
 *    - EXTI5 реагирует на PA5 (левый энкодер)
 *    - EXTI6 реагирует на PA6 (правый энкодер)
 *
 *    Оба фронта (восходящий и нисходящий) вызывают одно прерывание:
 *       EXTI9_5_IRQHandler().
 *
 * 2) Что происходит в момент прерывания?
 *
 *    Процесс:
 *      а) EXTI вызывает IRQ при изменении уровня на входе.
 *      б) В обработчике IRQ мы смотрим:
 *            если это линия ENC_L_EXTI_LINE (5), обрабатываем левый энкодер,
 *            если ENC_R_EXTI_LINE (6) — правый.
 *      в) Поскольку прерывание срабатывает на Оба фронта,
 *         необходимо определить, был ли это "тик".
 *
 *    Как определяется "тик"?
 *       - Мы отслеживаем только переход HIGH → LOW (спад).
 *       - Для этого запоминаем предыдущее состояние входа.
 *       - Если было: 1 → 0 → значит пришёл один моментный импульс энкодера.
 *
 *    Фильтрация дребезга:
 *       - У каждого колеса хранится время последнего принятого импульса.
 *       - Если прошло меньше ENC_MIN_TICK_INTERVAL_MS (например 2 мс),
 *         импульс игнорируется.
 *
 *    Когда импульс прошёл фильтрацию:
 *       s_leftTicks++;     // тики за «интервал»
 *       s_leftTotal++;     // общие тики за всё время
 *
 *    Таким образом:
 *       - s_leftTicks и s_rightTicks растут постоянно между вызовами
 *         Encoder_GetAndResetTicks().
 *
 * 3) Что делает Encoder_GetAndResetTicks()?
 *
 *    Эта функция вызывается пользователем ПЕРИОДИЧЕСКИ (например, каждые 10 мс).
 *
 *    Назначение:
 *       - забрать значение счётчиков «за интервал»
 *       - и обнулить их
 *
 *    Пример:
 *        (прошло 10 мс)
 *        левое колесо = 3 тика
 *        правое колесо = 2 тика
 *
 *        В этот момент программист вызывает:
 *
 *           uint32_t L, R;
 *           Encoder_GetAndResetTicks(&L, &R);
 *
 *        Результат:
 *           L = 3
 *           R = 2
 *        а внутренние буферы станут нулевыми:
 *           s_leftTicks = 0;
 *           s_rightTicks = 0;
 *
 *    Почему функция отключает прерывания (__disable_irq())?
 *       Потому что в этот момент может произойти новое прерывание EXTI,
 *       которое увеличит счётчики. Чтобы не было гонки данных,
 *       обнуление и копирование происходит атомарно.
 *
 * 4) Где использовать Encoder_GetAndResetTicks() ?
 *
 *    Обычно — в основном цикле или внутри таймера, который вызывается
 *    раз в фиксированный промежуток времени, например:
 *
 *       раз в 10 мс → получить тики → рассчитать скорость колеса
 *
 *    Пример:
 *       float v_left = Encoder_TicksToMM(L) / dt_ms;
 *       float v_right = Encoder_TicksToMM(R) / dt_ms;
 *
 * 5) Какие данные остаются неизменными?
 *
 *    Общие тики:
 *       s_leftTotal и s_rightTotal
 *
 *    Они никогда НЕ обнуляются автоматически и используются чтобы:
 *       - определить пройденный путь
 *       - сбрасывать путь только вручную, если нужно
 *
 *
 * ИТОГ:
 *   - Прерывания фиксируют импульсы и увеличивают счётчики.
 *   - Encoder_GetAndResetTicks() безопасно забирает эти тики и обнуляет интервал.
 *   - Общие тики всегда растут и используются для логики расстояния.
 *
 ******************************************************************************/
