// motor.h
#ifndef MOTOR_H
#define MOTOR_H

#include <stdint.h>
#include "../../CMSIS/Devices/STM32F4xx/Inc/STM32F429ZI/stm32f429xx.h"
#include "stm32f4xx.h"

/******************************************************************************
 *                              ОБЩЕЕ ОПИСАНИЕ
 *
 * Модуль motor.c обеспечивает управление двумя моторами постоянного тока
 * через H-мостовой драйвер. Каждый мотор имеет две линии направления (INx)
 * и одну линию PWM (формируется таймером TIM1).
 *
 * Подключение:
 *
 *                  ┌───────────────────────────────┐
 *                  │             STM32F429ZI        │
 *                  └───────────────────────────────┘
 *
 *   MOTOR_A:
 *       PWM  → TIM1_CH1 → PE9
 *       IN1  → PE2
 *       IN2  → PD11
 *
 *   MOTOR_B:
 *       PWM  → TIM1_CH2 → PE11
 *       IN3  → PD12
 *       IN4  → PD13
 *
 * IN1/IN2 и IN3/IN4 формируют направление вращения:
 *
 *        dir > 0:   IN1=0 IN2=1  (или аналогично для IN3/IN4)
 *        dir < 0:   IN1=1 IN2=0
 *        dir = 0:   IN1=0 IN2=0  → электротормоз
 *
 * PWM регулирует мощность двигателя через TIM1.
 *
 *****************************************************************************/

/******************************************************************************
 *                     НАСТРОЙКИ TIM1 ДЛЯ ГЕНЕРАЦИИ PWM
 *
 * Таймер TIM1 работает от частоты APB2 * 2 = 168 МГц.
 * Мы хотим частоту PWM = 20 кГц (плавное управление + отсутствие писка).
 *
 * Формула:
 *      f_PWM = f_TIM / ((PSC + 1) * (ARR + 1))
 *
 * Подбираем параметры:
 *
 *      f_TIM = 168 МГц
 *      target f_PWM = 20 кГц
 *
 * Требуемое произведение:
 *
 *      (PSC + 1) * (ARR + 1) = 8400
 *
 * Выбрано:
 *
 *      PSC = 83  → (PSC+1)=84
 *      ARR = 99  → (ARR+1)=100
 *
 * Проверка:
 *      f_PWM = 168 000 000 / (84 * 100) = 20000 Гц = 20 кГц
 *
 *****************************************************************************/

#define MOTOR_TIM1_PSC 83U /* Делитель: (PSC+1)=84 */
#define MOTOR_TIM1_ARR 99U /* Период: (ARR+1)=100 */

/******************************************************************************
 *                             ДИАПАЗОН PWM
 *
 * CCRx может принимать значения 0…ARR.
 *
 * MOTOR_PWM_MAX задаёт максимальную мощность двигателя.
 *
 *      CCR = 0   → 0%   мощности
 *      CCR = ARR → 99%  мощности
 *
 * Используется при вызове Motor_SetSpeed(id, speed):
 *
 *      speed ∈ [-99, +99]
 *
 * Модуль speed используется как CCR, знак определяет направление.
 *****************************************************************************/

#define MOTOR_PWM_MAX MOTOR_TIM1_ARR /* 0..99 */

/******************************************************************************
 *                           MOTOR ID
 *****************************************************************************/

typedef enum
{
    MOTOR_A = 0, /* Левый мотор: PWM=PE9, IN1=PE2, IN2=PD11 */
    MOTOR_B = 1  /* Правый мотор: PWM=PE11, IN3=PD12, IN4=PD13 */
} MotorId;

/******************************************************************************
 *                          Motor_Init()
 *
 * Делает полную аппаратную инициализацию:
 *
 *   ✔ включает тактирование портов GPIOD, GPIOE и таймера TIM1
 *   ✔ IN1=PE2, IN2=PD11, IN3=PD12, IN4=PD13 → настраиваются как выходы
 *   ✔ PWM-выводы PE9/PE11 → Alternate Function AF1 (TIM1_CH1/CH2)
 *   ✔ TIM1 настраивается в PWM mode 1 на двух каналах
 *   ✔ частота PWM = 20 кГц
 *   ✔ ARPE, preload, MOE включены
 *   ✔ моторы остановлены в конце
 *
 * Вызывать ОДИН раз в начале программы.
 *****************************************************************************/

void Motor_Init(void);

/******************************************************************************
 *                          Motor_SetSpeed(id, speed)
 *
 * Универсальная функция управления скоростью двигателя.
 *
 *  Параметры:
 *
 *      id    — какой мотор (MOTOR_A или MOTOR_B)
 *
 *      speed — диапазон:
 *
 *           speed > 0 → движение ВПЕРЁД
 *           speed < 0 → движение НАЗАД
 *           speed = 0 → полный стоп (INx=0, PWM=0)
 *
 *      |speed| = уровень мощности, 0..MOTOR_PWM_MAX (обычно 0..99)
 *
 *
 * Логика:
 *
 *    1. По знаку speed выбираются линии INx:
 *           dir > 0  → вперёд
 *           dir < 0  → назад
 *
 *    2. По модулю |speed| задаётся CCRx для PWM.
 *
 * Примеры:
 *
 *      Motor_SetSpeed(MOTOR_A, 50);   → A вперёд, 50% мощности
 *      Motor_SetSpeed(MOTOR_B, -80);  → B назад, 80% мощности
 *      Motor_SetSpeed(MOTOR_A, 0);    → стоп
 *
 *****************************************************************************/

void Motor_SetSpeed(MotorId id, int16_t speed);

/******************************************************************************
 *                               Motor_Stop(id)
 *
 * Полностью останавливает мотор:
 *
 *    - PWM = 0
 *    - INx = 0 (электротормоз)
 *
 * Эквивалент:
 *      Motor_SetSpeed(id, 0)
 *****************************************************************************/

void Motor_Stop(MotorId id);

#endif /* MOTOR_H */
