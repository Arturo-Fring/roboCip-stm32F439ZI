#include "MPU6050.h"
#include "usart.h"

#define I2C_DEV I2C1
#define I2C_TIMEOUT 100000UL

/******************************************************************************
 * I2C_WaitSR1()
 *
 * Вспомогательная функция.
 * Ждёт установки указанного флага в регистре SR1.
 *
 * Используется там, где модуль I2C "обещает" выставить флаг,
 * например:
 *   - SB  (Start Bit установлен)
 *   - ADDR (адрес принят slave'ом)
 *   - TXE  (передающий буфер пуст)
 *   - RXNE (принят байт)
 *   - BTF  (завершён байт)
 *
 * Если флаг не установился за разумное время → возвращаем 0 (ошибка).
 ******************************************************************************/
static uint8_t I2C_WaitSR1(uint32_t flag)
{
    uint32_t t = 0;
    while (!(I2C_DEV->SR1 & flag))
    {
        if (t++ > I2C_TIMEOUT)
            return 0; // произошёл таймаут — что-то зависло
    }
    return 1;
}

/******************************************************************************
 * I2C_WriteReg(reg, data)
 *
 * Записывает ОДИН байт в выбранный регистр MPU6050.
 *
 * Формат транзакции I2C:
 *
 *   START
 *   адрес + write
 *   байт_адреса_регистра
 *   байт_данных
 *   STOP
 *
 * Функция выполняет весь протокол:
 *   - генерирует START
 *   - ждёт флаг SB
 *   - отправляет адрес MPU6050 (0x68 << 1 | 0)
 *   - ждёт ADDR
 *   - записывает номер регистра
 *   - пишет данные
 *   - ждёт BTF (Byte Transfer Finished)
 *   - генерирует STOP
 *
 * При любой ошибке выводит SR1/SR2 для диагностики.
 ******************************************************************************/
static uint8_t I2C_WriteReg(uint8_t reg, uint8_t data)
{
    uint32_t t;

    /* --- START condition --- */
    I2C_DEV->CR1 |= I2C_CR1_START;

    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_SB))
    {
        if (t++ > I2C_TIMEOUT)
        {
            USART_Println("I2C_WriteReg: timeout SB");
            goto error;
        }
    }

    /* --- Send address with Write bit --- */
    I2C_DEV->DR = (MPU6050_ADDR << 1) | 0;

    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_ADDR))
    {
        if (t++ > I2C_TIMEOUT)
        {
            USART_Println("I2C_WriteReg: timeout ADDR");
            goto error;
        }
    }

    // Сброс ADDR: обязательно читаем SR1/SR2
    (void)I2C_DEV->SR1;
    (void)I2C_DEV->SR2;

    /* --- Send register address --- */
    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_TXE))
    {
        if (t++ > I2C_TIMEOUT)
        {
            USART_Println("I2C_WriteReg: timeout TXE (reg)");
            goto error;
        }
    }
    I2C_DEV->DR = reg;

    /* --- Send data byte --- */
    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_TXE))
    {
        if (t++ > I2C_TIMEOUT)
        {
            USART_Println("I2C_WriteReg: timeout TXE (data)");
            goto error;
        }
    }
    I2C_DEV->DR = data;

    /* --- Wait for BTF (both bytes transmitted) --- */
    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_BTF))
    {
        if (t++ > I2C_TIMEOUT)
        {
            USART_Println("I2C_WriteReg: timeout BTF");
            goto error;
        }
    }

    /* --- STOP --- */
    I2C_DEV->CR1 |= I2C_CR1_STOP;
    return 1;

error:
{
    // Если ошибка — читаем SR1/SR2 для диагностики
    uint32_t sr1 = I2C_DEV->SR1;
    uint32_t sr2 = I2C_DEV->SR2;

    // STOP обязателен, иначе шина зависнет
    I2C_DEV->CR1 |= I2C_CR1_STOP;

    USART_Print("I2C_WriteReg ERROR, SR1 = 0x");
    USART_PrintHex(sr1);
    USART_Print(" SR2 = 0x");
    USART_PrintlnHex(sr2);
}
    return 0;
}

/******************************************************************************
 * I2C_Read1(reg, *val)
 *
 * Чтение одного байта из регистра MPU6050.
 * Формат чтения по I2C:
 *
 *   START
 *   адрес + write
 *   номер_регистра
 *   (BTF)
 *   RE-START
 *   адрес + read
 *   читем_1_байт (ACK=0)
 *   STOP
 *
 * Функция реализует классический протокол I2C Read из любого регистра.
 *
 * Почему ACK=0?
 *   При чтении последнего (или единственного) байта мастеру нельзя
 *   отправлять ACK — иначе slave будет думать, что мы хотим читать дальше.
 ******************************************************************************/
static uint8_t I2C_Read1(uint8_t reg, uint8_t *val)
{
    uint32_t t;

    if (!val)
        return 0;

    /* --- Step 1: WRITE — send register address --- */

    // START
    I2C_DEV->CR1 |= I2C_CR1_START;

    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_SB))
    {
        if (t++ > I2C_TIMEOUT)
            goto error;
    }

    // Send address + write
    I2C_DEV->DR = (MPU6050_ADDR << 1) | 0;

    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_ADDR))
    {
        if (t++ > I2C_TIMEOUT)
            goto error;
    }

    (void)I2C_DEV->SR1;
    (void)I2C_DEV->SR2;

    // Send register number
    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_TXE))
    {
        if (t++ > I2C_TIMEOUT)
            goto error;
    }
    I2C_DEV->DR = reg;

    // Wait for BTF
    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_BTF))
    {
        if (t++ > I2C_TIMEOUT)
            goto error;
    }

    /* --- Step 2: RE-START and Read --- */

    I2C_DEV->CR1 |= I2C_CR1_START;

    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_SB))
    {
        if (t++ > I2C_TIMEOUT)
            goto error;
    }

    // Send address + read
    I2C_DEV->DR = (MPU6050_ADDR << 1) | 1;

    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_ADDR))
    {
        if (t++ > I2C_TIMEOUT)
            goto error;
    }

    (void)I2C_DEV->SR1;
    (void)I2C_DEV->SR2;

    // For 1 byte read: ACK=0 + STOP immediately
    I2C_DEV->CR1 &= ~I2C_CR1_ACK;
    I2C_DEV->CR1 |= I2C_CR1_STOP;

    // Wait for RXNE
    t = 0;
    while (!(I2C_DEV->SR1 & I2C_SR1_RXNE))
    {
        if (t++ > I2C_TIMEOUT)
            goto error_after_stop;
    }

    *val = I2C_DEV->DR; // Read byte

    // Restore ACK
    I2C_DEV->CR1 |= I2C_CR1_ACK;
    return 1;

error_after_stop:
    I2C_DEV->CR1 |= I2C_CR1_STOP;

error:
{
    uint32_t sr1 = I2C_DEV->SR1;
    uint32_t sr2 = I2C_DEV->SR2;
    I2C_DEV->CR1 |= I2C_CR1_STOP;
}
    return 0;
}

/******************************************************************************
 * MPU6050_Init()
 *
 * Полная инициализация датчика:
 *   1) Сброс устройства (задержка после reset)
 *   2) Выбор источника тактирования (PLL по X-gyro — рекомендуется даташитом)
 *   3) Установка DLPF (фильтр нижних частот)
 *   4) Настройка частоты выборки (SMPLRT_DIV)
 *   5) Настройка диапазона гироскопа
 *   6) Настройка диапазона акселерометра
 *   7) Настройка прерывания Data Ready
 ******************************************************************************/
void MPU6050_Init(void)
{
    USART_Println("MPU6050_Init: start");

    // 1) Reset device
    if (!I2C_WriteReg(MPU6050_REG_PWR_MGMT_1, MPU6050_DEVICE_RESET))
    {
        USART_Println("MPU6050_Init: failed to write reset");
        return;
    }

    // Задержка после reset — датчик перезапускается
    for (volatile uint32_t i = 0; i < 500000; i++)
        __NOP();

    // 2) Clock source = PLL (X-gyro)
    I2C_WriteReg(MPU6050_REG_PWR_MGMT_1, MPU6050_CLOCK_PLL_XGYRO);

    // 3) DLPF — фильтр
    I2C_WriteReg(MPU6050_REG_CONFIG, 0x03);

    // 4) Sample rate divider: 1kHz / (7+1) = 125 Hz
    I2C_WriteReg(MPU6050_REG_SMPLRT_DIV, MPU6050_SMPLRT_7DIV);

    // 5) Gyro range: ±2000 dps
    I2C_WriteReg(MPU6050_REG_GYRO_CONFIG, MPU6050_GYRO_CONFIG_2000);

    // 6) Accel range: ±8g
    I2C_WriteReg(MPU6050_REG_ACCEL_CONFIG, MPU6050_ACCEL_CONFIG_8G);

    // 7) Interrupt config
    I2C_WriteReg(MPU6050_REG_INT_PIN_CFG, 0x00);
    I2C_WriteReg(MPU6050_REG_INT_ENABLE, MPU6050_INT_DATA_RDY);

    USART_Println("MPU6050_Init: done");
}

/******************************************************************************
 * MPU6050_ReadWhoAmI()
 *
 * Чтение регистра WHO_AM_I.
 * Ожидаемое значение — 0x68.
 *
 * Используется для проверки работоспособности связи по I2C.
 ******************************************************************************/
uint8_t MPU6050_ReadWhoAmI(void)
{
    uint8_t id = 0;

    if (!I2C_Read1(MPU6050_REG_WHO_AM_I, &id))
    {
        USART_Println("MPU6050_ReadWhoAmI: I2C_Read failed");
        return 0;
    }

    USART_Print("WHO_AM_I = 0x");
    USART_PrintlnHex(id);

    return id;
}

/******************************************************************************
 * MPU6050_ReadRaw()
 *
 * Читает 14 последовательных регистров:
 *
 *   ACCEL_X/Y/Z (6 байтов)
 *   TEMP        (2 байта)
 *   GYRO_X/Y/Z  (6 байтов)
 *
 * ВНИМАНИЕ: данная реализация читает 14 байтов
 *           14 ОТДЕЛЬНЫМИ транзакциями I2C.
 *
 * Это медленно, но надёжно.
 *
 * На выходе:
 *   accel[0..2] = акселерометр (сырые значения)
 *   gyro [0..2] = гироскоп     (сырые значения)
 *   temp        = температура   (сырой int16_t)
 ******************************************************************************/
void MPU6050_ReadRaw(int16_t accel[3], int16_t gyro[3], int16_t *temp)
{
    uint8_t b;
    uint8_t ok = 1;
    uint8_t buf[14];

    uint8_t regs[14] = {
        0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
        0x41, 0x42,
        0x43, 0x44, 0x45, 0x46, 0x47, 0x48};

    // Читаем 14 байтов по одному
    for (int i = 0; i < 14; i++)
    {
        if (!I2C_Read1(regs[i], &b))
        {
            ok = 0;
            break;
        }
        buf[i] = b;
    }

    if (!ok)
    {
        USART_Println("MPU6050_ReadRaw: I2C_Read failed");
        return;
    }

    // Склейка 16-битных значений (big endian → little endian)
    accel[0] = (buf[0] << 8) | buf[1];
    accel[1] = (buf[2] << 8) | buf[3];
    accel[2] = (buf[4] << 8) | buf[5];

    int16_t t = (buf[6] << 8) | buf[7];
    if (temp)
        *temp = t;

    gyro[0] = (buf[8] << 8) | buf[9];
    gyro[1] = (buf[10] << 8) | buf[11];
    gyro[2] = (buf[12] << 8) | buf[13];
}

/******************************************************************************
 * Функции преобразования сырых данных в реальные единицы
 ******************************************************************************/

float MPU6050_AccelLSB_to_g(int16_t raw)
{
    // Для диапазона ±8g масштаб ≈ 4096 LSB/g
    return (float)raw / 4096.0f;
}

float MPU6050_GyroLSB_to_dps(int16_t raw)
{
    // Для диапазона ±2000 dps → 16.4 LSB/dps
    return (float)raw / 16.4f;
}

float MPU6050_TempLSB_to_C(int16_t raw)
{
    return 36.53f + raw / 340.0f;
}

/******************************************************************************
 * MPU6050_CalibrateGyro()
 *
 * Запоминает смещение гироскопа.
 * Алгоритм:
 *   - снять N отсчётов
 *   - усреднить значения
 *   - перевести в dps
 *
 * Используется для компенсации дрейфа гироскопа.
 ******************************************************************************/
void MPU6050_CalibrateGyro(float *bias_x, float *bias_y, float *bias_z)
{
    int32_t sum_x = 0, sum_y = 0, sum_z = 0;
    int16_t accel[3], gyro[3], temp;

    const int N = 5000;

    for (int i = 0; i < N; i++)
    {
        MPU6050_ReadRaw(accel, gyro, &temp);

        sum_x += gyro[0];
        sum_y += gyro[1];
        sum_z += gyro[2];

        for (volatile uint32_t d = 0; d < 2000; d++)
            __NOP(); // небольшая задержка
    }

    if (bias_x)
        *bias_x = MPU6050_GyroLSB_to_dps(sum_x / (float)N);
    if (bias_y)
        *bias_y = MPU6050_GyroLSB_to_dps(sum_y / (float)N);
    if (bias_z)
        *bias_z = MPU6050_GyroLSB_to_dps(sum_z / (float)N);
}

/******************************************************************************
 *                           КАК РАБОТАЕТ I2C НА STM32
 *
 * Данный драйвер I2C реализован в полностью «ручном» (bare-metal) виде,
 * используя регистры I2C_CR1/CR2/SR1/SR2 и последовательные проверки флагов.
 *
 * Ниже описаны ключевые понятия: START, RESTART, STOP, ACK, SB, ADDR, BTF,
 * TXE, RXNE — и логика, по которой работает каждая функция чтения/записи.
 *
 * ---------------------------------------------------------------------------
 * 1. START (генерация условия START)
 * ---------------------------------------------------------------------------
 * I2C работает по протоколу:
 *
 *     START → адрес ведомого → чтение/запись → STOP
 *
 * «START» — это специальный фронт на SDA/SCL, обозначающий начало транзакции.
 *
 * На STM32 он создаётся установкой бита:
 *
 *      I2C_CR1 |= START;
 *
 * После чего устройство самостоятельно формирует сигнал.
 *
 * MCU подтверждает успешный START флагом:
 *
 *      SR1.SB (Start Bit)
 *
 * Пока SB=0 → START не успел сформироваться → ждём.
 *
 * В коде:
 *
 *      while (!(SR1 & SB)) таймаут;
 *
 * ---------------------------------------------------------------------------
 * 2. Отправка адреса ведомому (slave address)
 * ---------------------------------------------------------------------------
 * После успешного START нужно отправить адрес ведомого в регистр DR:
 *
 *      DR = (addr << 1) | R/W;
 *
 * В случае MPU6050:
 *      addr = 0x68
 *      write → 0
 *      read  → 1
 *
 * После этого STM32 ждёт подтверждение от ведомого и устанавливает SR1.ADDR.
 *
 *      while (!(SR1 & ADDR)) таймаут;
 *
 * Чтобы этот флаг сбросить, нужно «прочитать» SR1 и SR2:
 *
 *      (void)SR1; (void)SR2;
 *
 * Если этого не сделать — шина зависает.
 *
 * ---------------------------------------------------------------------------
 * 3. TXE — Transmit Buffer Empty
 * ---------------------------------------------------------------------------
 * Когда мы передаём данные (регистр, байт...), STM32 ставит TXE=1,
 * когда готов принять новый байт в DR.
 *
 *      while (!(SR1 & TXE)) — ждём, когда можно писать в DR.
 *
 * ---------------------------------------------------------------------------
 * 4. RXNE — Receive Buffer Not Empty
 * ---------------------------------------------------------------------------
 * RXNE=1 означает, что DR содержит принятый байт, его можно читать.
 *
 *      while (!(SR1 & RXNE)) — ждём момента, когда данные получены.
 *
 * ---------------------------------------------------------------------------
 * 5. BTF — Byte Transfer Finished
 * ---------------------------------------------------------------------------
 * BTF=1 означает: *все предыдущие байты переданы*, и сдвиговый буфер пуст.
 *
 * Это важно перед STOP или перед RESTART.
 *
 * ---------------------------------------------------------------------------
 * 6. ACK / NACK — подтверждение при чтении
 * ---------------------------------------------------------------------------
 * Когда мастер читает байты, он должен отправлять slave-у подтверждения
 * (ACK = 1) или отказ от подтверждения (ACK = 0):
 *
 *   - ACK = 1 → «я готов принять ещё байты»
 *   - ACK = 0 → «я читаю последний байт, дальше STOP»
 *
 * При чтении *одного* байта последовательность:
 *
 *      ACK = 0;
 *      STOP = 1;
 *      RXNE → читаем DR;
 *
 * После чтения — вернуть ACK=1, чтобы следующие обращения работали.
 *
 * ---------------------------------------------------------------------------
 * 7. STOP — окончание транзакции
 * ---------------------------------------------------------------------------
 * STOP (CR1.STOP=1) формирует на шине сигнал «конец передачи».
 * После STOP линии SDA/SCL возвращаются в состояние высокого уровня.
 *
 * Это обязательно для завершения любой записи/чтения.
 *
 * ---------------------------------------------------------------------------
 * 8. RE-START — повторный START без STOP
 * ---------------------------------------------------------------------------
 * READ всегда выглядит так:
 *
 *     START
 *     адрес + write
 *     передать номер регистра
 *     (wait BTF)
 *     RE-START
 *     адрес + read
 *     читать байты
 *     STOP
 *
 * Именно RE-START позволяет сначала указать номер регистра,
 * а потом прочитать его значение.
 *
 * ---------------------------------------------------------------------------
 * 9. Возможные ошибки и почему мы их ловим
 * ---------------------------------------------------------------------------
 *
 * На STM32 I2C может «зависнуть» в нескольких ситуациях:
 *
 *   ► SB не устанавливается
 *         — что-то удерживает SDA в нуле
 *         — слейв не успевает освобождать шину
 *         — неправильная конфигурация GPIO
 *
 *   ► ADDR не устанавливается
 *         — MPU6050 не отвечает (нет pull-up? кабель? питание?)
 *         — неверный адрес (AD0=1 → адрес = 0x69)
 *
 *   ► TXE не приходит
 *         — передача захлебнулась
 *
 *   ► RXNE не приходит
 *         — slave не прислал данные
 *
 *   ► BTF не приходит
 *         — шина зависла между байтами
 *
 * Все такие проблемы приводят к зависанию, поэтому код проверяет каждый
 * шаг по таймауту. Если что-то не так — код формирует STOP и пишет SR1/SR2.
 *
 * Это *правильная* практика.
 *
 * ---------------------------------------------------------------------------
 * 10. Почему этот драйвер надёжный
 * ---------------------------------------------------------------------------
 *
 *  ✔ мы контролируем все флаги SR1 → исключаем зависания,
 *  ✔ все действия сопровождаются STOP → правильно завершаем транзакции,
 *  ✔ RESTART реализован корректно,
 *  ✔ ACK включается/выключается в нужные моменты,
 *  ✔ все ошибки логируются через USART,
 *  ✔ не используем длинные burst-последовательности (меньше точек сбоя),
 *  ✔ ручное управление даёт нам полный контроль над протоколом.
 *
 * ---------------------------------------------------------------------------
 * 11. Что можно улучшить (по желанию)
 * ---------------------------------------------------------------------------
 *
 *  • Burst-чтение 14 байтов за 1 транзакцию (ускорение ×10)
 *  • DMA-чтение
 *  • Обработка ошибок SR1.AF (NACK) более детально
 *  • Стейт-машина для прозрачных ошибок
 *
 * Но текущий драйвер *идеально подходит для надёжной первичной работы*.
 *
 *****************************************************************************/
