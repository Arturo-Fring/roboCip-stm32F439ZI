// GU521_init.c
//
// Инициализация интерфейса I2C1 для работы с модулем GY-521 (MPU6050).
//
// Подключение (Nucleo-F429ZI):
//   PB8 → I2C1_SCL (AF4)
//   PB9 → I2C1_SDA (AF4)
//
// Ключевые моменты настройки:
//   - Включение тактирования GPIOB и I2C1
//   - Настройка PB8/PB9 в режим "Alternate Function 4" (I2C)
//   - Открытый сток (open-drain), подтяжка pull-up → требуется для I2C
//   - Формирование параметров временной диаграммы I2C (CCR, TRISE)
//   - Включение ACK и модуля I2C
//
// Стандартный режим I2C: 100 кГц
// Частота шины APB1 = 42 МГц (в STM32F429ZI)

#include "GU521_init.h"
#include "usart.h"

void GY521_I2C1_Init(void)
{
    /**************************************************************************
     * 1. Включаем тактирование GPIOB и I2C1
     **************************************************************************/

    // Разрешение тактирования порта B
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;

    // Разрешение тактирования модуля I2C1 на шине APB1
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;

    /**************************************************************************
     * 2. Настройка GPIOB: PB8(SCL), PB9(SDA)
     *
     *    Для I2C важно:
     *      - режим альтернативной функции (AF mode)
     *      - выбор AF4 (для I2C1)
     *      - open-drain выход (I2C физически работает через «открытый сток»)
     *      - обязательная подтяжка к питанию (pull-up)
     *      - высокая скорость (лучше фронты)
     **************************************************************************/

    // MODER → режим Alternate Function (10) для PB8 и PB9
    GPIOB->MODER &= ~(GPIO_MODER_MODE8_Msk | GPIO_MODER_MODE9_Msk);
    GPIOB->MODER |= (GPIO_MODER_MODE8_1 | GPIO_MODER_MODE9_1); // 10b = AF

    // OTYPER → open-drain (требование I2C)
    GPIOB->OTYPER |= GPIO_OTYPER_OT8 | GPIO_OTYPER_OT9;

    // OSPEEDR → высокая скорость (для корректных фронтов сигнала)
    GPIOB->OSPEEDR |= GPIO_OSPEEDR_OSPEED8_Msk | GPIO_OSPEEDR_OSPEED9_Msk;

    // PUPDR → pull-up (для линии SDA/SCL обязательны подтяжки)
    GPIOB->PUPDR &= ~(GPIO_PUPDR_PUPD8_Msk | GPIO_PUPDR_PUPD9_Msk);
    GPIOB->PUPDR |= (GPIO_PUPDR_PUPD8_0 | GPIO_PUPDR_PUPD9_0); // 01b = pull-up

    // AFR[1] → альтернативная функция 4 (I2C1)
    GPIOB->AFR[1] &= ~(GPIO_AFRH_AFSEL8_Msk | GPIO_AFRH_AFSEL9_Msk);
    GPIOB->AFR[1] |= (4U << GPIO_AFRH_AFSEL8_Pos) |
                     (4U << GPIO_AFRH_AFSEL9_Pos); // AF4 = I2C1

    /**************************************************************************
     * 3. Сброс конфигурации I2C1 перед настройкой
     *
     *     Зачем?
     *       → Иногда I2C может «зависнуть», например, если SDA/SCL были удержаны
     *         в низком уровне. Полный сброс регистров = гарантированное начало.
     **************************************************************************/

    I2C1->CR1 = 0;  // Управляющие биты (включение, ACK, старт/стоп)
    I2C1->CR2 = 0;  // Настройка частоты APB1 и управления прерываниями
    I2C1->OAR1 = 0; // Адрес устройства (для slave режима — нам не нужен)
    I2C1->OAR2 = 0;
    I2C1->CCR = 0;   // Основной таймер I2C (скорость SCL)
    I2C1->TRISE = 0; // Компенсация time-rise линии SDA/SCL

    /**************************************************************************
     * 4. Настройка временной диаграммы I2C
     *
     *    CR2:
     *      — нижние 6 бит задают частоту APB1 в МГц
     *        В F429 APB1 = 42 МГц → пишем 42
     *
     *    CCR:
     *      — определяет период SCL в стандартном режиме:
     *          T_scl = 2 * CCR * T_APB
     *      — отсюда CCR = F_APB / (2 * F_I2C)
     *
     *    TRISE:
     *      — корректирует максимальный фронт сигнала SDA/SCL
     *        Для SM (100 kHz): TRISE = F_APB(MHz) + 1
     **************************************************************************/

    I2C1->CR2 = 42U; // Частота APB1 = 42 МГц

    uint32_t i2c_freq = 42000000UL; // 42 MHz
    uint32_t i2c_speed = 100000UL;  // 100 kHz
    uint32_t ccr_value = i2c_freq / (2U * i2c_speed);

    // Аппаратные ограничения CCR
    if (ccr_value < 4U)
        ccr_value = 4U;
    if (ccr_value > 0xFFFU)
        ccr_value = 0xFFFU;

    I2C1->CCR = ccr_value;  // Стандартный режим (FS=0)
    I2C1->TRISE = 42U + 1U; // TRISE = F_APB(MHz) + 1 = 42 + 1 = 43

    /**************************************************************************
     * 5. Включаем аппаратный ACK
     *
     *    То есть при чтении данных микроконтроллер автоматически отправляет
     *    подтверждение ведомому устройству (slave).
     **************************************************************************/
    I2C1->CR1 |= I2C_CR1_ACK;

    /**************************************************************************
     * 6. Включаем I2C (бит PE — Peripheral Enable)
     **************************************************************************/
    I2C1->CR1 |= I2C_CR1_PE;

    /**************************************************************************
     * 7. Необязательный лог через USART → удобно при отладке
     **************************************************************************/
    USART_Print("I2C1 CR1 = 0x");
    USART_PrintHex(I2C1->CR1);
    USART_Print(" CR2 = 0x");
    USART_PrintlnHex(I2C1->CR2);
}
